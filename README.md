# CodingProblem

## About This Project

This is a C# coding practice repository containing various programming problems and solutions. The project includes implementations of common algorithms and data structure problems, along with comprehensive documentation about C# concepts.

## Project Structure

The project contains:
- **Algorithm Implementations**: Factorial, Fibonacci, Palindrome checking, duplicate finding, and number swapping
- **C# Concept Examples**: Interface vs Abstract Class implementations
- **Documentation**: Detailed explanations and interview questions

## Documentation

### Available Documents

- [C# Interface vs Abstract Class Guide](docs/CSharp-Interface-vs-AbstractClass-Guide.md) - Comprehensive guide with 40+ interview questions and answers about interfaces and abstract classes in C#
- [C# Collections Complete Guide](docs/CSharp-Collections-Complete-Guide.md) - Detailed technical documentation covering all C# collection types, performance considerations, and interview questions
- [C# Design Patterns Complete Guide](docs/CSharp-Design-Patterns-Complete-Guide.md) - Comprehensive guide covering all 23 GoF design patterns with modern C# implementations, real-world examples, and interview questions
- [C# Boxing, Unboxing, Stack & Heap Guide](docs/CSharp-Boxing-Unboxing-Stack-Heap.md) - Complete guide to value types, reference types, boxing/unboxing, and memory management with performance considerations
- [C# ref and out Keywords Guide](docs/CSharp-Ref-Out-Keywords-Guide.md) - Comprehensive guide to parameter passing in C# including ref, out, in modifiers with real-world examples and interview questions

### SOLID Design Principles (Object-Oriented Design Foundation)

#### **SOLID Overview**
- [SOLID Design Principles Introduction](docs/solid-principles/SOLID-Design-Principles-Introduction.md) - Complete guide to SOLID principles introduced by Robert C. Martin, including history, cross-principle comparisons, and real-world ASP.NET Core applications

#### **The Five SOLID Principles**
- [Single Responsibility Principle (SRP)](docs/solid-principles/single-responsibility-principle.md) - One class, one responsibility - ensure each class has only one reason to change
- [Open/Closed Principle (OCP)](docs/solid-principles/open-closed-principle.md) - Open for extension, closed for modification - add features without changing existing code
- [Liskov Substitution Principle (LSP)](docs/solid-principles/liskov-substitution-principle.md) - Subtypes must be substitutable for base types - maintain contracts in inheritance
- [Interface Segregation Principle (ISP)](docs/solid-principles/interface-segregation-principle.md) - Many small interfaces over one fat interface - clients shouldn't depend on unused methods
- [Dependency Inversion Principle (DIP)](docs/solid-principles/dependency-inversion-principle.md) - Depend on abstractions, not concretions - high-level and low-level modules depend on interfaces

**What You'll Learn:**
- Historical context and evolution of each principle
- Detailed before/after code examples with violations and corrections
- Real-world enterprise scenarios in ASP.NET Core applications
- Interview questions with comprehensive answers
- Cross-principle relationships and how they work together
- Common anti-patterns and how to avoid them
- Performance and maintainability impact analysis

### Design Patterns (Academic & Practical)

#### **Pattern Overview**
- [Design Patterns Index](docs/design-patterns/index.md) - Academic foundation, theoretical analysis, and comprehensive pattern catalog

#### **Creational Patterns** (Object Creation)
- [Singleton](docs/design-patterns/creational/singleton.md) - Ensure single instance with global access
- [Factory Method](docs/design-patterns/creational/factory-method.md) - Create objects without specifying exact classes
- [Abstract Factory](docs/design-patterns/creational/abstract-factory.md) - Create families of related objects
- [Builder](docs/design-patterns/creational/builder.md) - Construct complex objects step by step
- [Prototype](docs/design-patterns/creational/prototype.md) - Create objects by cloning existing instances

#### **Structural Patterns** (Object Composition)
- [Adapter](docs/design-patterns/structural/adapter.md) - Make incompatible interfaces work together
- [Bridge](docs/design-patterns/structural/bridge.md) - Separate abstraction from implementation
- [Composite](docs/design-patterns/structural/composite.md) - Compose objects into tree structures
- [Decorator](docs/design-patterns/structural/decorator.md) - Add behavior to objects dynamically
- [Facade](docs/design-patterns/structural/facade.md) - Provide simplified interface to complex subsystem
- [Proxy](docs/design-patterns/structural/proxy.md) - Provide placeholder or surrogate for another object

#### **Behavioral Patterns** (Object Interaction)
- [Chain of Responsibility](docs/design-patterns/behavioral/chain-of-responsibility.md) - Pass requests along chain of handlers
- [Command](docs/design-patterns/behavioral/command.md) - Encapsulate requests as objects
- [Mediator](docs/design-patterns/behavioral/mediator.md) - Define how objects interact
- [Observer](docs/design-patterns/behavioral/observer.md) - Notify multiple objects about state changes
- [Strategy](docs/design-patterns/behavioral/strategy.md) - Encapsulate algorithms and make them interchangeable
- [Template Method](docs/design-patterns/behavioral/template-method.md) - Define algorithm skeleton in base class

## Getting Started

1. Clone the repository
2. Open the solution file in Visual Studio: `src/CodingProblem.slnx`
3. Build and run the project to see the implementations in action
4. Explore the documentation for detailed explanations of C# concepts

## Topics Covered

- **Algorithms**: Factorial calculation, Fibonacci sequence, palindrome detection
- **Data Structures**: Array manipulation, duplicate detection
- **C# Concepts**: Interface implementation, abstract classes, inheritance, collections
- **Memory Management**: Value types, reference types, boxing/unboxing, stack/heap allocation
- **Parameter Passing**: ref, out, in modifiers and their use cases
- **Best Practices**: SOLID principles, design patterns, performance considerations
- **Object-Oriented Design**: SOLID principles, design patterns, clean architecture